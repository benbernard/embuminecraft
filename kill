--  vim: set ft=lua:

MoveTracker = {}
MoveTracker_mt = {}
MoveTracker_mt.__index = MoveTracker

function MoveTracker.new()
    local object = { face = 0 }
    setmetatable(object, MoveTracker_mt)
    return object
end

function MoveTracker.left(self)
    print("Turning left")
    self.face = (self.face - 1) % 4
    return turtle.turnLeft()
end

function MoveTracker.right(self)
    print("Turning right")
    self.face = (self.face + 1) % 4
    return turtle.turnRight()
end

function MoveTracker.f(self)
    print("Move forward")
    return turtle.forward()
end

function MoveTracker.b(self)
    print("Move backward")
    return turtle.back()
end

function MoveTracker.max_forward(self)
    print("Max forward")
    while self:f() do
    end
end

function MoveTracker.max_backward(self)
    print("Max backward")
    while self:b() do
    end
end

function MoveTracker.has_facing(self, facing)
    return facing == self.face
end

function MoveTracker.turn_to(self, facing)
    print("Turning to " .. facing)
    if math.abs(facing - self.face) >= 2 then
        while not self:has_facing(facing) do
            self:right()
        end
    else
        while not self:has_facing(facing) do
            self:left()
        end
    end
end

function MoveTracker.return_to_base(self)
    print("Returning to base")
    self:turn_to(2)
    self:max_forward()
    if turtle.detect() then
        self:turn_to(3)
        self:max_forward()
        
        if turtle.detect() then
            self:turn_to(0)
        end
    end
end

-- Slot list --
-- 1: Cobblestone
-- 2: Fuel

function is_cobble()
    turtle.select(1)
    return turtle.compare()
end

mov = MoveTracker.new()
print(mov.left)
print(mov.left)
print(mov)
-- mov:left()

-- mov:return_to_base()
mov:turn_to(3)
-- mov:left()
