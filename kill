--  vim: set ft=lua:

MoveTracker = {}
MoveTracker_mt = {}
MoveTracker_mt.__index = MoveTracker

function MoveTracker.new()
    local object = { face = 0 }
    setmetatable(object, MoveTracker_mt)
    return object
end

function MoveTracker.left(self)
    --print("Turning left")
    self.face = (self.face - 1) % 4
    return turtle.left()
end

mov.right = function(self)
    print("Turning right")
    mov.face = (self.face + 1) % 4
    return turtle.right()
end

mov.f = function(self)
    print("Move forward")
    return turtle.forward()
end

mov.b = function(self)
    print("Move backward")
    return turtle.backward()
end

mov.max_forward = function(self)
    print("Max forward")
    while mov:f() do
    end
end

mov.max_backward = function(self)
    print("Max backward")
    while mov:b() do
    end
end

mov.has_facing = function(self, facing)
    return facing == self.face
end

mov.turn_to = function(self, facing)
    print("Turning to " .. facing)
    if math.abs(facing - self.face) >= 2 then
        while not self:has_facing(facing) do
            self:right()
        end
    else
        while not self:has_facing(facing) do
            self:left()
        end
    end
end

mov.return_to_base = function(self)
    print("Returning to base")
    self:turn_to(2)
    self:max_forward()
    if is_cobble() then
        self:turn_to(3)
        self:max_forward()
        
        if is_cobble() then
            self:turn_to(0)
        end
    end
end

-- Slot list --
-- 1: Cobblestone
-- 2: Fuel

is_cobble = function()
    turtle.select(1)
    return turtle.compare()
end

mov = MoveTracker.new()
print(mov.left)
print(mov.left)
print(mov)
mov:left(mov)

-- mov:return_to_base()
-- mov:turn_to(2)
-- mov:left()
